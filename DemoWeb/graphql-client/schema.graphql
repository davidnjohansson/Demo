"""
The `@defer` directive may be provided for fragment spreads and inline fragments
to inform the executor to delay the execution of the current fragment to
indicate deprioritization of the current fragment. A query with `@defer`
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred is
delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this defer directive. This label is intended to give client
  applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String

  """
  Deferred when true.
  """
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the
backend can leverage technology such as asynchronous iterators to provide a
partial list in the initial response, and additional list items in subsequent
responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this stream directive. This label is intended to give client
  applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String

  """
  The initial elements that shall be send down to the consumer.
  """
  initialCount: Int! = 0

  """
  Streamed when true.
  """
  if: Boolean
) on FIELD

type Address {
  id: Int!
  active: Boolean!
  address1: String
  city: String
  zipCode: String
  addressTypeId: Int!
  addressType: AddressType!
  positionId: Int
  position: Position
  workplaces: [Workplace!]!
  visitingAddressFor: [Customer!]!
  invoiceAddressFor: [Customer!]!
}

type AddressCollectionSegment {
  items: [Address!]

  """
  Information to aid in pagination.
  """
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input AddressFilterInput {
  and: [AddressFilterInput!]
  or: [AddressFilterInput!]
  id: ComparableInt32OperationFilterInput
  active: BooleanOperationFilterInput
  address1: StringOperationFilterInput
  city: StringOperationFilterInput
  zipCode: StringOperationFilterInput
  addressTypeId: ComparableInt32OperationFilterInput
  addressType: AddressTypeFilterInput
  positionId: ComparableNullableOfInt32OperationFilterInput
  position: PositionFilterInput
  workplaces: ListFilterInputTypeOfWorkplaceFilterInput
  visitingAddressFor: ListFilterInputTypeOfCustomerFilterInput
  invoiceAddressFor: ListFilterInputTypeOfCustomerFilterInput
}

input AddressSortInput {
  id: SortEnumType
  active: SortEnumType
  address1: SortEnumType
  city: SortEnumType
  zipCode: SortEnumType
  addressTypeId: SortEnumType
  addressType: AddressTypeSortInput
  positionId: SortEnumType
  position: PositionSortInput
}

type AddressType {
  id: Int!
  addressTypeName: String!
  addresses: [Address!]!
}

input AddressTypeFilterInput {
  and: [AddressTypeFilterInput!]
  or: [AddressTypeFilterInput!]
  id: ComparableInt32OperationFilterInput
  addressTypeName: StringOperationFilterInput
  addresses: ListFilterInputTypeOfAddressFilterInput
}

input AddressTypeSortInput {
  id: SortEnumType
  addressTypeName: SortEnumType
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

"""
Information about the offset pagination.
"""
type CollectionSegmentInfo {
  """
  Indicates whether more items exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more items exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!
}

input ComparableDoubleOperationFilterInput {
  eq: Float
  neq: Float
  in: [Float!]
  nin: [Float!]
  gt: Float
  ngt: Float
  gte: Float
  ngte: Float
  lt: Float
  nlt: Float
  lte: Float
  nlte: Float
}

input ComparableInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int!]
  nin: [Int!]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input ComparableNullableOfInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

type Customer {
  id: Int!
  active: Boolean!
  customerName: String!
  customerNo: String!
  visitingAddressId: Int!
  visitingAddress: Address
  invoiceAddressId: Int!
  invoiceAddress: Address
  payerId: Int!
  payer: Customer
  contractorId: Int!
  contractor: Customer
  corporationId: Int!
  corporation: Customer
  workplaces: [Workplace!]!
  payerFor: [Customer!]!
  contractorFor: [Customer!]!
  corporationFor: [Customer!]!
}

type CustomerCollectionSegment {
  items: [Customer!]

  """
  Information to aid in pagination.
  """
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CustomerFilterInput {
  and: [CustomerFilterInput!]
  or: [CustomerFilterInput!]
  id: ComparableInt32OperationFilterInput
  active: BooleanOperationFilterInput
  customerName: StringOperationFilterInput
  customerNo: StringOperationFilterInput
  visitingAddressId: ComparableInt32OperationFilterInput
  visitingAddress: AddressFilterInput
  invoiceAddressId: ComparableInt32OperationFilterInput
  invoiceAddress: AddressFilterInput
  payerId: ComparableInt32OperationFilterInput
  payer: CustomerFilterInput
  contractorId: ComparableInt32OperationFilterInput
  contractor: CustomerFilterInput
  corporationId: ComparableInt32OperationFilterInput
  corporation: CustomerFilterInput
  workplaces: ListFilterInputTypeOfWorkplaceFilterInput
  payerFor: ListFilterInputTypeOfCustomerFilterInput
  contractorFor: ListFilterInputTypeOfCustomerFilterInput
  corporationFor: ListFilterInputTypeOfCustomerFilterInput
}

input CustomerSortInput {
  id: SortEnumType
  active: SortEnumType
  customerName: SortEnumType
  customerNo: SortEnumType
  visitingAddressId: SortEnumType
  visitingAddress: AddressSortInput
  invoiceAddressId: SortEnumType
  invoiceAddress: AddressSortInput
  payerId: SortEnumType
  payer: CustomerSortInput
  contractorId: SortEnumType
  contractor: CustomerSortInput
  corporationId: SortEnumType
  corporation: CustomerSortInput
}

input ListFilterInputTypeOfAddressFilterInput {
  all: AddressFilterInput
  none: AddressFilterInput
  some: AddressFilterInput
  any: Boolean
}

input ListFilterInputTypeOfCustomerFilterInput {
  all: CustomerFilterInput
  none: CustomerFilterInput
  some: CustomerFilterInput
  any: Boolean
}

input ListFilterInputTypeOfWorkplaceFilterInput {
  all: WorkplaceFilterInput
  none: WorkplaceFilterInput
  some: WorkplaceFilterInput
  any: Boolean
}

type Mutation {
  upsertWorkplace(input: UpsertWorkplaceInput!): MutationOutput!
}

type MutationOutput {
  id: Int
  validationErrors: [ValidationError!]!
}

type Position {
  id: Int!
  latitude: Float!
  longitude: Float!
  addresses: [Address!]!
  workplaces: [Workplace!]!
}

type PositionCollectionSegment {
  items: [Position!]

  """
  Information to aid in pagination.
  """
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PositionFilterInput {
  and: [PositionFilterInput!]
  or: [PositionFilterInput!]
  id: ComparableInt32OperationFilterInput
  latitude: ComparableDoubleOperationFilterInput
  longitude: ComparableDoubleOperationFilterInput
  addresses: ListFilterInputTypeOfAddressFilterInput
  workplaces: ListFilterInputTypeOfWorkplaceFilterInput
}

input PositionSortInput {
  id: SortEnumType
  latitude: SortEnumType
  longitude: SortEnumType
}

type Query {
  addresses(skip: Int, take: Int, where: AddressFilterInput, order: [AddressSortInput!]): AddressCollectionSegment
  customers(skip: Int, take: Int, where: CustomerFilterInput, order: [CustomerSortInput!]): CustomerCollectionSegment
  positions(skip: Int, take: Int, where: PositionFilterInput, order: [PositionSortInput!]): PositionCollectionSegment
  workplaces(skip: Int, take: Int, where: WorkplaceFilterInput, order: [WorkplaceSortInput!]): WorkplaceCollectionSegment
}

enum SortEnumType {
  ASC
  DESC
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

type Subscription {
  workplaceInserted: Workplace!
  workplaceUpdated: Workplace!
}

input UpsertWorkplaceInput {
  active: Boolean
  workplaceName: String
  customerId: Int
  address1: String
  city: String
  zipCode: String
  latitude: Float
  longitude: Float
  id: Int
  onlyValidate: Boolean
}

type ValidationError {
  message: String!
  property: String!
}

type Workplace {
  id: Int!
  active: Boolean!
  workplaceName: String!
  addressId: Int!
  address: Address!
  customerId: Int!
  customer: Customer!
}

type WorkplaceCollectionSegment {
  items: [Workplace!]

  """
  Information to aid in pagination.
  """
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input WorkplaceFilterInput {
  and: [WorkplaceFilterInput!]
  or: [WorkplaceFilterInput!]
  id: ComparableInt32OperationFilterInput
  active: BooleanOperationFilterInput
  workplaceName: StringOperationFilterInput
  addressId: ComparableInt32OperationFilterInput
  address: AddressFilterInput
  customerId: ComparableInt32OperationFilterInput
  customer: CustomerFilterInput
}

input WorkplaceSortInput {
  id: SortEnumType
  active: SortEnumType
  workplaceName: SortEnumType
  addressId: SortEnumType
  address: AddressSortInput
  customerId: SortEnumType
  customer: CustomerSortInput
}
