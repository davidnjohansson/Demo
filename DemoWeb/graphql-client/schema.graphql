"""
The `@defer` directive may be provided for fragment spreads and inline fragments
to inform the executor to delay the execution of the current fragment to
indicate deprioritization of the current fragment. A query with `@defer`
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred is
delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this defer directive. This label is intended to give client
  applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String

  """
  Deferred when true.
  """
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the
backend can leverage technology such as asynchronous iterators to provide a
partial list in the initial response, and additional list items in subsequent
responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this stream directive. This label is intended to give client
  applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String

  """
  The initial elements that shall be send down to the consumer.
  """
  initialCount: Int! = 0

  """
  Streamed when true.
  """
  if: Boolean
) on FIELD

"""
The `@specifiedBy` directive is used within the type system definition language
to provide a URL for specifying the behavior of custom scalar definitions.
"""
directive @specifiedBy(
  """
  The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types.
  """
  url: String!
) on SCALAR

type Address implements IEntity {
  id: Int!
  active: Boolean
  address1: String
  city: String
  zipCode: String
  addressTypeId: Int!
  addressType: AddressType!
  positionId: Int
  position: Position
  workplaces: [Workplace!]!
  visitingAddressFor: [Customer!]!
  invoiceAddressFor: [Customer!]!
  persons: [Person!]!
  newInvoiceAddressFor: [WorkplaceOwner!]!
  oldInvoiceAddressFor: [WorkplaceOwner!]!
}

type AddressCollectionSegment {
  items: [Address!]

  """
  Information to aid in pagination.
  """
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input AddressFilterInput {
  and: [AddressFilterInput!]
  or: [AddressFilterInput!]
  id: ComparableInt32OperationFilterInput
  active: BooleanOperationFilterInput
  address1: StringOperationFilterInput
  city: StringOperationFilterInput
  zipCode: StringOperationFilterInput
  addressTypeId: ComparableInt32OperationFilterInput
  addressType: AddressTypeFilterInput
  positionId: ComparableNullableOfInt32OperationFilterInput
  position: PositionFilterInput
  workplaces: ListFilterInputTypeOfWorkplaceFilterInput
  visitingAddressFor: ListFilterInputTypeOfCustomerFilterInput
  invoiceAddressFor: ListFilterInputTypeOfCustomerFilterInput
  persons: ListFilterInputTypeOfPersonFilterInput
  newInvoiceAddressFor: ListFilterInputTypeOfWorkplaceOwnerFilterInput
  oldInvoiceAddressFor: ListFilterInputTypeOfWorkplaceOwnerFilterInput
}

input AddressSortInput {
  id: SortEnumType
  active: SortEnumType
  address1: SortEnumType
  city: SortEnumType
  zipCode: SortEnumType
  addressTypeId: SortEnumType
  addressType: AddressTypeSortInput
  positionId: SortEnumType
  position: PositionSortInput
}

type AddressType implements IEntity {
  id: Int!
  addressTypeName: String
  addresses: [Address!]!
}

input AddressTypeFilterInput {
  and: [AddressTypeFilterInput!]
  or: [AddressTypeFilterInput!]
  id: ComparableInt32OperationFilterInput
  addressTypeName: StringOperationFilterInput
  addresses: ListFilterInputTypeOfAddressFilterInput
}

input AddressTypeSortInput {
  id: SortEnumType
  addressTypeName: SortEnumType
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

"""
Information about the offset pagination.
"""
type CollectionSegmentInfo {
  """
  Indicates whether more items exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more items exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!
}

input ComparableDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime!]
  nin: [DateTime!]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input ComparableDoubleOperationFilterInput {
  eq: Float
  neq: Float
  in: [Float!]
  nin: [Float!]
  gt: Float
  ngt: Float
  gte: Float
  ngte: Float
  lt: Float
  nlt: Float
  lte: Float
  nlte: Float
}

input ComparableInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int!]
  nin: [Int!]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input ComparableNullableOfDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input ComparableNullableOfDoubleOperationFilterInput {
  eq: Float
  neq: Float
  in: [Float]
  nin: [Float]
  gt: Float
  ngt: Float
  gte: Float
  ngte: Float
  lt: Float
  nlt: Float
  lte: Float
  nlte: Float
}

input ComparableNullableOfInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

type Contact implements IEntity {
  id: Int!
  contactName: String
  department: String
  active: Boolean
  gDPR_Deleted: String
  customerId: Int!
  customer: Customer!
  personId: Int
  person: Person
  workplaces: [Workplace!]!
  contactWorkplaces: [ContactWorkplace!]!
}

input ContactFilterInput {
  and: [ContactFilterInput!]
  or: [ContactFilterInput!]
  id: ComparableInt32OperationFilterInput
  contactName: StringOperationFilterInput
  department: StringOperationFilterInput
  active: BooleanOperationFilterInput
  gDPR_Deleted: StringOperationFilterInput
  customerId: ComparableInt32OperationFilterInput
  customer: CustomerFilterInput
  personId: ComparableNullableOfInt32OperationFilterInput
  person: PersonFilterInput
  workplaces: ListFilterInputTypeOfWorkplaceFilterInput
  contactWorkplaces: ListFilterInputTypeOfContactWorkplaceFilterInput
}

input ContactSortInput {
  id: SortEnumType
  contactName: SortEnumType
  department: SortEnumType
  active: SortEnumType
  gDPR_Deleted: SortEnumType
  customerId: SortEnumType
  customer: CustomerSortInput
  personId: SortEnumType
  person: PersonSortInput
}

type ContactWorkplace {
  contactId: Int!
  contact: Contact!
  workplaceId: Int!
  workplace: Workplace!
}

input ContactWorkplaceFilterInput {
  and: [ContactWorkplaceFilterInput!]
  or: [ContactWorkplaceFilterInput!]
  contactId: ComparableInt32OperationFilterInput
  contact: ContactFilterInput
  workplaceId: ComparableInt32OperationFilterInput
  workplace: WorkplaceFilterInput
}

type Customer implements IEntity {
  id: Int!
  active: Boolean
  customerName: String!
  customerNo: String!
  visitingAddressId: Int
  visitingAddress: Address
  invoiceAddressId: Int
  invoiceAddress: Address
  payerId: Int
  payer: Customer
  contractorId: Int
  contractor: Customer
  corporationId: Int
  corporation: Customer
  workplaces: [Workplace!]!
  payerFor: [Customer!]!
  contractorFor: [Customer!]!
  corporationFor: [Customer!]!
  validationCustomers: [ValidationCustomer!]!
  contacts: [Contact!]!
  workplaceOwnerFor: [WorkplaceOwner!]!
}

type CustomerCollectionSegment {
  items: [Customer!]

  """
  Information to aid in pagination.
  """
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CustomerFilterInput {
  and: [CustomerFilterInput!]
  or: [CustomerFilterInput!]
  id: ComparableInt32OperationFilterInput
  active: BooleanOperationFilterInput
  customerName: StringOperationFilterInput
  customerNo: StringOperationFilterInput
  visitingAddressId: ComparableNullableOfInt32OperationFilterInput
  visitingAddress: AddressFilterInput
  invoiceAddressId: ComparableNullableOfInt32OperationFilterInput
  invoiceAddress: AddressFilterInput
  payerId: ComparableNullableOfInt32OperationFilterInput
  payer: CustomerFilterInput
  contractorId: ComparableNullableOfInt32OperationFilterInput
  contractor: CustomerFilterInput
  corporationId: ComparableNullableOfInt32OperationFilterInput
  corporation: CustomerFilterInput
  workplaces: ListFilterInputTypeOfWorkplaceFilterInput
  payerFor: ListFilterInputTypeOfCustomerFilterInput
  contractorFor: ListFilterInputTypeOfCustomerFilterInput
  corporationFor: ListFilterInputTypeOfCustomerFilterInput
  validationCustomers: ListFilterInputTypeOfValidationCustomerFilterInput
  contacts: ListFilterInputTypeOfContactFilterInput
  workplaceOwnerFor: ListFilterInputTypeOfWorkplaceOwnerFilterInput
}

input CustomerSortInput {
  id: SortEnumType
  active: SortEnumType
  customerName: SortEnumType
  customerNo: SortEnumType
  visitingAddressId: SortEnumType
  visitingAddress: AddressSortInput
  invoiceAddressId: SortEnumType
  invoiceAddress: AddressSortInput
  payerId: SortEnumType
  payer: CustomerSortInput
  contractorId: SortEnumType
  contractor: CustomerSortInput
  corporationId: SortEnumType
  corporation: CustomerSortInput
}

"""
The `DateTime` scalar represents an ISO-8601 compliant date time type.
"""
scalar DateTime

enum EnumValidationOperation {
  EQUALS
  DOES_NOT_EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESSER_THAN
  LESSER_THAN_OR_EQUAL
  MATCHES_REGEX
  IS_NULL
  IS_NOT_NULL
  ANNAN_REGEL
  ANNAN_REGEL_FLERA_ANY
  ANNAN_REGEL_FLERA_ALL
  CONTAINS
  DOES_NOT_CONTAIN
  DOES_NOT_MATCH_REGEX
  LONGER_THAN
  LONGER_THAN_OR_EQUAL
  SHORTER_THAN
  SHORTER_THAN_OR_EQUAL
  STARTS_WITH
  DOES_NOT_START_WITH
  ENDS_WITH
  DOES_NOT_END_WITH
  COUNT
  NOT_COUNT
  COUNT_IS_MORE_THAN
  COUNT_IS_MORE_THAN_OR_EQUAL
  COUNT_IS_LESS_THAN
  COUNT_IS_LESS_THAN_OR_EQUAL
}

input EnumValidationOperationOperationFilterInput {
  eq: EnumValidationOperation
  neq: EnumValidationOperation
  in: [EnumValidationOperation!]
  nin: [EnumValidationOperation!]
}

interface IEntity {
  id: Int!
}

input ListFilterInputTypeOfAddressFilterInput {
  all: AddressFilterInput
  none: AddressFilterInput
  some: AddressFilterInput
  any: Boolean
}

input ListFilterInputTypeOfContactFilterInput {
  all: ContactFilterInput
  none: ContactFilterInput
  some: ContactFilterInput
  any: Boolean
}

input ListFilterInputTypeOfContactWorkplaceFilterInput {
  all: ContactWorkplaceFilterInput
  none: ContactWorkplaceFilterInput
  some: ContactWorkplaceFilterInput
  any: Boolean
}

input ListFilterInputTypeOfCustomerFilterInput {
  all: CustomerFilterInput
  none: CustomerFilterInput
  some: CustomerFilterInput
  any: Boolean
}

input ListFilterInputTypeOfPersonFilterInput {
  all: PersonFilterInput
  none: PersonFilterInput
  some: PersonFilterInput
  any: Boolean
}

input ListFilterInputTypeOfValidationCustomerFilterInput {
  all: ValidationCustomerFilterInput
  none: ValidationCustomerFilterInput
  some: ValidationCustomerFilterInput
  any: Boolean
}

input ListFilterInputTypeOfValidationFilterInput {
  all: ValidationFilterInput
  none: ValidationFilterInput
  some: ValidationFilterInput
  any: Boolean
}

input ListFilterInputTypeOfValidationOperationFilterInput {
  all: ValidationOperationFilterInput
  none: ValidationOperationFilterInput
  some: ValidationOperationFilterInput
  any: Boolean
}

input ListFilterInputTypeOfValidationRuleFilterInput {
  all: ValidationRuleFilterInput
  none: ValidationRuleFilterInput
  some: ValidationRuleFilterInput
  any: Boolean
}

input ListFilterInputTypeOfWorkplaceFilterInput {
  all: WorkplaceFilterInput
  none: WorkplaceFilterInput
  some: WorkplaceFilterInput
  any: Boolean
}

input ListFilterInputTypeOfWorkplaceOwnerFilterInput {
  all: WorkplaceOwnerFilterInput
  none: WorkplaceOwnerFilterInput
  some: WorkplaceOwnerFilterInput
  any: Boolean
}

type Mutation {
  upsertWorkplace(input: UpsertWorkplaceInput!): MutationOutput!
}

type MutationOutput {
  id: Int
  validationErrors: [ValidationError!]!
}

type Operation implements IEntity {
  id: Int!
  active: Boolean
  operationName: String
  validationOperations: [ValidationOperation!]!
}

input OperationFilterInput {
  and: [OperationFilterInput!]
  or: [OperationFilterInput!]
  id: ComparableInt32OperationFilterInput
  active: BooleanOperationFilterInput
  operationName: StringOperationFilterInput
  validationOperations: ListFilterInputTypeOfValidationOperationFilterInput
}

type Person implements IEntity {
  id: Int!
  socialSecurityNumber: String
  personName: String
  addressId: Int
  address: Address
  contacts: [Contact!]!
}

input PersonFilterInput {
  and: [PersonFilterInput!]
  or: [PersonFilterInput!]
  id: ComparableInt32OperationFilterInput
  socialSecurityNumber: StringOperationFilterInput
  personName: StringOperationFilterInput
  addressId: ComparableNullableOfInt32OperationFilterInput
  address: AddressFilterInput
  contacts: ListFilterInputTypeOfContactFilterInput
}

input PersonSortInput {
  id: SortEnumType
  socialSecurityNumber: SortEnumType
  personName: SortEnumType
  addressId: SortEnumType
  address: AddressSortInput
}

type Position implements IEntity {
  id: Int!
  latitude: Float!
  longitude: Float!
  addresses: [Address!]!
  workplaces: [Workplace!]!
}

type PositionCollectionSegment {
  items: [Position!]

  """
  Information to aid in pagination.
  """
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PositionFilterInput {
  and: [PositionFilterInput!]
  or: [PositionFilterInput!]
  id: ComparableInt32OperationFilterInput
  latitude: ComparableDoubleOperationFilterInput
  longitude: ComparableDoubleOperationFilterInput
  addresses: ListFilterInputTypeOfAddressFilterInput
  workplaces: ListFilterInputTypeOfWorkplaceFilterInput
}

input PositionSortInput {
  id: SortEnumType
  latitude: SortEnumType
  longitude: SortEnumType
}

type Query {
  addresses(skip: Int, take: Int, where: AddressFilterInput, order: [AddressSortInput!]): AddressCollectionSegment
  customers(skip: Int, take: Int, where: CustomerFilterInput, order: [CustomerSortInput!]): CustomerCollectionSegment
  positions(skip: Int, take: Int, where: PositionFilterInput, order: [PositionSortInput!]): PositionCollectionSegment
  workplaces(skip: Int, take: Int, where: WorkplaceFilterInput, order: [WorkplaceSortInput!]): WorkplaceCollectionSegment
}

enum SortEnumType {
  ASC
  DESC
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

type Subscription {
  workplaceInserted: Workplace!
  workplaceUpdated: Workplace!
}

input UpsertAddressInput {
  address1: String
  city: String
  zipCode: String
  upsertPositionInput: UpsertPositionInput
  id: Int
  onlyValidate: Boolean
}

input UpsertPositionInput {
  latitude: Float
  longitude: Float
  id: Int
  onlyValidate: Boolean
}

input UpsertWorkplaceInput {
  active: Boolean
  workplaceName: String
  customerId: Int
  upsertAddressInput: UpsertAddressInput
  id: Int
  onlyValidate: Boolean
}

type Validation implements IEntity {
  id: Int!
  name: String!
  active: Boolean!
  general: Boolean!
  onlyWarning: Boolean!
  validationGroupId: Int
  validationGroup: ValidationGroup
  validationCustomers: [ValidationCustomer!]!
  validationRules: [ValidationRule!]!
  validationOperations: [ValidationOperation!]!
}

type ValidationCustomer implements IEntity {
  id: Int!
  validationId: Int!
  validation: Validation!
  customerId: Int!
  customer: Customer!
}

input ValidationCustomerFilterInput {
  and: [ValidationCustomerFilterInput!]
  or: [ValidationCustomerFilterInput!]
  id: ComparableInt32OperationFilterInput
  validationId: ComparableInt32OperationFilterInput
  validation: ValidationFilterInput
  customerId: ComparableInt32OperationFilterInput
  customer: CustomerFilterInput
}

type ValidationError {
  message: String!
  typeName: String!
  propertyName: String!
}

input ValidationFilterInput {
  and: [ValidationFilterInput!]
  or: [ValidationFilterInput!]
  id: ComparableInt32OperationFilterInput
  name: StringOperationFilterInput
  active: BooleanOperationFilterInput
  general: BooleanOperationFilterInput
  onlyWarning: BooleanOperationFilterInput
  validationGroupId: ComparableNullableOfInt32OperationFilterInput
  validationGroup: ValidationGroupFilterInput
  validationCustomers: ListFilterInputTypeOfValidationCustomerFilterInput
  validationRules: ListFilterInputTypeOfValidationRuleFilterInput
  validationOperations: ListFilterInputTypeOfValidationOperationFilterInput
}

type ValidationGroup implements IEntity {
  id: Int!
  groupName: String!
  validations: [Validation!]!
}

input ValidationGroupFilterInput {
  and: [ValidationGroupFilterInput!]
  or: [ValidationGroupFilterInput!]
  id: ComparableInt32OperationFilterInput
  groupName: StringOperationFilterInput
  validations: ListFilterInputTypeOfValidationFilterInput
}

type ValidationOperation implements IEntity {
  id: Int!
  validationId: Int!
  validation: Validation!
  operationId: Int!
  operation: Operation!
}

input ValidationOperationFilterInput {
  and: [ValidationOperationFilterInput!]
  or: [ValidationOperationFilterInput!]
  id: ComparableInt32OperationFilterInput
  validationId: ComparableInt32OperationFilterInput
  validation: ValidationFilterInput
  operationId: ComparableInt32OperationFilterInput
  operation: OperationFilterInput
}

type ValidationRule implements IEntity {
  id: Int!
  entityName: String!
  propertyName: String!
  enumOperationId: Int!
  enumOperation: EnumValidationOperation!
  errorMessage: String
  valueNumeric: Float
  valueAlphanumeric: String
  valueDateTime: DateTime
  valueBoolean: Boolean
  valueForeignKey: Int
  regexPattern: String
  allowNull: Boolean!
  inverseValidationRuleId: Int
  inverseValidationRule: ValidationRule
  validationId: Int!
  validation: Validation!
  inverseValidationRules: [ValidationRule!]!
}

input ValidationRuleFilterInput {
  and: [ValidationRuleFilterInput!]
  or: [ValidationRuleFilterInput!]
  id: ComparableInt32OperationFilterInput
  entityName: StringOperationFilterInput
  propertyName: StringOperationFilterInput
  enumOperationId: ComparableInt32OperationFilterInput
  enumOperation: EnumValidationOperationOperationFilterInput
  errorMessage: StringOperationFilterInput
  valueNumeric: ComparableNullableOfDoubleOperationFilterInput
  valueAlphanumeric: StringOperationFilterInput
  valueDateTime: ComparableNullableOfDateTimeOperationFilterInput
  valueBoolean: BooleanOperationFilterInput
  valueForeignKey: ComparableNullableOfInt32OperationFilterInput
  regexPattern: StringOperationFilterInput
  allowNull: BooleanOperationFilterInput
  inverseValidationRuleId: ComparableNullableOfInt32OperationFilterInput
  inverseValidationRule: ValidationRuleFilterInput
  validationId: ComparableInt32OperationFilterInput
  validation: ValidationFilterInput
  inverseValidationRules: ListFilterInputTypeOfValidationRuleFilterInput
}

type Workplace implements IEntity {
  id: Int!
  active: Boolean
  workplaceName: String!
  addressId: Int!
  address: Address!
  customerId: Int!
  customer: Customer!
  positionId: Int
  position: Position
  contactId: Int
  contact: Contact
  contactWorkplaces: [ContactWorkplace!]!
  workplaceOwners: [WorkplaceOwner!]!
}

type WorkplaceCollectionSegment {
  items: [Workplace!]

  """
  Information to aid in pagination.
  """
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input WorkplaceFilterInput {
  and: [WorkplaceFilterInput!]
  or: [WorkplaceFilterInput!]
  id: ComparableInt32OperationFilterInput
  active: BooleanOperationFilterInput
  workplaceName: StringOperationFilterInput
  addressId: ComparableInt32OperationFilterInput
  address: AddressFilterInput
  customerId: ComparableInt32OperationFilterInput
  customer: CustomerFilterInput
  positionId: ComparableNullableOfInt32OperationFilterInput
  position: PositionFilterInput
  contactId: ComparableNullableOfInt32OperationFilterInput
  contact: ContactFilterInput
  contactWorkplaces: ListFilterInputTypeOfContactWorkplaceFilterInput
  workplaceOwners: ListFilterInputTypeOfWorkplaceOwnerFilterInput
}

type WorkplaceOwner {
  id: Int!
  fromDay: DateTime!
  executedAt: DateTime
  createdBy: String
  createdAt: DateTime!
  workplaceId: Int!
  workplace: Workplace!
  customerId: Int!
  customer: Customer!
  newInvoiceAddressId: Int
  newInvoiceAddress: Address
  oldInvoiceAddressId: Int
  oldInvoiceAddress: Address
}

input WorkplaceOwnerFilterInput {
  and: [WorkplaceOwnerFilterInput!]
  or: [WorkplaceOwnerFilterInput!]
  id: ComparableInt32OperationFilterInput
  fromDay: ComparableDateTimeOperationFilterInput
  executedAt: ComparableNullableOfDateTimeOperationFilterInput
  createdBy: StringOperationFilterInput
  createdAt: ComparableDateTimeOperationFilterInput
  workplaceId: ComparableInt32OperationFilterInput
  workplace: WorkplaceFilterInput
  customerId: ComparableInt32OperationFilterInput
  customer: CustomerFilterInput
  newInvoiceAddressId: ComparableNullableOfInt32OperationFilterInput
  newInvoiceAddress: AddressFilterInput
  oldInvoiceAddressId: ComparableNullableOfInt32OperationFilterInput
  oldInvoiceAddress: AddressFilterInput
}

input WorkplaceSortInput {
  id: SortEnumType
  active: SortEnumType
  workplaceName: SortEnumType
  addressId: SortEnumType
  address: AddressSortInput
  customerId: SortEnumType
  customer: CustomerSortInput
  positionId: SortEnumType
  position: PositionSortInput
  contactId: SortEnumType
  contact: ContactSortInput
}
